import { BaseController, BaseControllerInput, IAccount, IGasLimitEstimator, Transaction, TransactionOnNetwork } from "../core";
import { INetworkProvider } from "../networkProviders/interface";
import * as resources from "./resources";
export declare class TokenManagementController extends BaseController {
    private factory;
    private transactionAwaiter;
    private parser;
    constructor(options: {
        chainID: string;
        networkProvider: INetworkProvider;
        gasLimitEstimator?: IGasLimitEstimator;
    });
    createTransactionForIssuingFungible(sender: IAccount, nonce: bigint, options: resources.IssueFungibleInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedIssueFungible(txHash: string): Promise<resources.EsdtOutput[]>;
    parseIssueFungible(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForIssuingSemiFungible(sender: IAccount, nonce: bigint, options: resources.IssueSemiFungibleInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedIssueSemiFungible(txHash: string): Promise<resources.EsdtOutput[]>;
    parseIssueSemiFungible(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForIssuingNonFungible(sender: IAccount, nonce: bigint, options: resources.IssueNonFungibleInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedIssueNonFungible(txHash: string): Promise<resources.EsdtOutput[]>;
    parseIssueNonFungible(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForRegisteringMetaEsdt(sender: IAccount, nonce: bigint, options: resources.RegisterMetaESDTInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedRegisterMetaEsdt(txHash: string): Promise<resources.EsdtOutput[]>;
    parseRegisterMetaEsdt(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForRegisteringAndSettingRoles(sender: IAccount, nonce: bigint, options: resources.RegisterRolesInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedRegisterAndSettingRoles(txHash: string): Promise<resources.EsdtOutput[]>;
    parseRegisterAndSetAllRoles(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForSetBurnRoleGlobally(sender: IAccount, nonce: bigint, options: resources.BurnRoleGloballyInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedSetBurnRoleGlobally(txHash: string): Promise<void>;
    parseSetBurnRoleGlobally(transactionOnNetwork: TransactionOnNetwork): void;
    createTransactionForUnsettingBurnRoleGlobally(sender: IAccount, nonce: bigint, options: resources.BurnRoleGloballyInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedUnsetBurnRoleGlobally(txHash: string): Promise<void>;
    parseUnsetBurnRoleGlobally(transactionOnNetwork: TransactionOnNetwork): void;
    createTransactionForSettingSpecialRoleOnFungibleToken(sender: IAccount, nonce: bigint, options: resources.FungibleSpecialRoleInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedSetSpecialRoleOnFungibleToken(txHash: string): Promise<resources.SpecialRoleOutput[]>;
    parseSetSpecialRoleOnFungible(transactionOnNetwork: TransactionOnNetwork): resources.SpecialRoleOutput[];
    createTransactionForUnsettingSpecialRoleOnFungibleToken(sender: IAccount, nonce: bigint, options: resources.UnsetFungibleSpecialRoleInput & BaseControllerInput): Promise<Transaction>;
    createTransactionForSettingSpecialRoleOnSemiFungibleToken(sender: IAccount, nonce: bigint, options: resources.SemiFungibleSpecialRoleInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedSetSpecialRoleOnSemiFungibleToken(txHash: string): Promise<resources.SpecialRoleOutput[]>;
    parseSetSpecialRoleOnSemiFungibleToken(transactionOnNetwork: TransactionOnNetwork): resources.SpecialRoleOutput[];
    createTransactionForUnsettingSpecialRoleOnSemiFungibleToken(sender: IAccount, nonce: bigint, options: resources.UnsetSemiFungibleSpecialRoleInput & BaseControllerInput): Promise<Transaction>;
    createTransactionForSettingSpecialRoleOnMetaESDT(sender: IAccount, nonce: bigint, options: resources.SemiFungibleSpecialRoleInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedSetSpecialRoleOnMetaESDTToken(txHash: string): Promise<resources.SpecialRoleOutput[]>;
    parseSetSpecialRoleOnMetaESDTToken(transactionOnNetwork: TransactionOnNetwork): resources.SpecialRoleOutput[];
    createTransactionForUnsettingSpecialRoleOnMetaESDT(sender: IAccount, nonce: bigint, options: resources.UnsetSemiFungibleSpecialRoleInput & BaseControllerInput): Promise<Transaction>;
    createTransactionForSettingSpecialRoleOnNonFungibleToken(sender: IAccount, nonce: bigint, options: resources.SpecialRoleInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedSetSpecialRoleOnNonFungibleToken(txHash: string): Promise<resources.SpecialRoleOutput[]>;
    parseSetSpecialRoleOnNonFungibleToken(transactionOnNetwork: TransactionOnNetwork): resources.SpecialRoleOutput[];
    createTransactionForUnsettingSpecialRoleOnNonFungibleToken(sender: IAccount, nonce: bigint, options: resources.UnsetSpecialRoleInput & BaseControllerInput): Promise<Transaction>;
    createTransactionForCreatingNft(sender: IAccount, nonce: bigint, options: resources.MintInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedCreateNft(txHash: string): Promise<resources.MintNftOutput[]>;
    parseNftCreate(transactionOnNetwork: TransactionOnNetwork): resources.MintNftOutput[];
    createTransactionForPausing(sender: IAccount, nonce: bigint, options: resources.PausingInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedPause(txHash: string): Promise<resources.EsdtOutput[]>;
    parsePause(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForUnpausing(sender: IAccount, nonce: bigint, options: resources.PausingInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedUnpause(txHash: string): Promise<resources.EsdtOutput[]>;
    parseUnpause(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForFreezing(sender: IAccount, nonce: bigint, options: resources.ManagementInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedFreeze(txHash: string): Promise<resources.EsdtOutput[]>;
    parseFreeze(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForUnFreezing(sender: IAccount, nonce: bigint, options: resources.ManagementInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedUnfreeze(txHash: string): Promise<resources.EsdtOutput[]>;
    parseUnfreeze(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForWiping(sender: IAccount, nonce: bigint, options: resources.ManagementInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedWipe(txHash: string): Promise<resources.EsdtOutput[]>;
    parseWipe(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForLocaMinting(sender: IAccount, nonce: bigint, options: resources.LocalMintInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedLocalMint(txHash: string): Promise<resources.EsdtOutput[]>;
    parseLocalMint(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForLocalBurning(sender: IAccount, nonce: bigint, options: resources.LocalBurnInput & BaseControllerInput): Promise<Transaction>;
    awaitCompleteLocalBurn(txHash: string): Promise<resources.EsdtOutput[]>;
    parseLocalBurn(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForUpdatingAttributes(sender: IAccount, nonce: bigint, options: resources.UpdateAttributesInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedUpdateAttributes(txHash: string): Promise<resources.EsdtOutput[]>;
    parseUpdateAttributes(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForAddingQuantity(sender: IAccount, nonce: bigint, options: resources.UpdateQuantityInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedAddQuantity(txHash: string): Promise<resources.EsdtOutput[]>;
    parseAddQuantity(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForBurningQuantity(sender: IAccount, nonce: bigint, options: resources.UpdateQuantityInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedBurnQuantity(txHash: string): Promise<resources.EsdtOutput[]>;
    parseBurnQuantity(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForModifyingRoyalties(sender: IAccount, nonce: bigint, options: resources.ModifyRoyaltiesInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedModifyRoyalties(txHash: string): Promise<resources.EsdtOutput[]>;
    parseModifyRoyalties(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForSettingNewUris(sender: IAccount, nonce: bigint, options: resources.SetNewUriInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedSetNewUris(txHash: string): Promise<resources.EsdtOutput[]>;
    parseSetNewUris(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForModifyingCreator(sender: IAccount, nonce: bigint, options: resources.SetNewUriInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedModifyCreator(txHash: string): Promise<resources.ModifyingCreatorOutput[]>;
    parseModifyCreator(transactionOnNetwork: TransactionOnNetwork): resources.ModifyingCreatorOutput[];
    createTransactionForUpdatingMetadata(sender: IAccount, nonce: bigint, options: resources.SetNewUriInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedUpdateMetadata(txHash: string): Promise<resources.EsdtOutput[]>;
    parseUpdateMetadata(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForMetadataRecreate(sender: IAccount, nonce: bigint, options: resources.SetNewUriInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedMetadataRecreate(txHash: string): Promise<resources.EsdtOutput[]>;
    parseMetadataRecreate(transactionOnNetwork: TransactionOnNetwork): resources.EsdtOutput[];
    createTransactionForChangingTokenToDynamic(sender: IAccount, nonce: bigint, options: resources.SetNewUriInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedChangeTokenToDynamic(txHash: string): Promise<resources.ChangeToDynamicOutput[]>;
    parseChangeTokenToDynamic(transactionOnNetwork: TransactionOnNetwork): resources.ChangeToDynamicOutput[];
    createTransactionForUpdatingTokenId(sender: IAccount, nonce: bigint, options: resources.UpdateTokenIDInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedUpdateTokenId(txHash: string): Promise<TransactionOnNetwork>;
    createTransactionForRegisteringDynamicToken(sender: IAccount, nonce: bigint, options: resources.RegisteringDynamicTokenInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedRegisterDynamicToken(txHash: string): Promise<resources.EsdtOutput[]>;
    parseRegisterDynamicToken(transactionOnNetwork: TransactionOnNetwork): resources.RegisterDynamicOutput[];
    createTransactionForRegisteringDynamicTokenAndSettingRoles(sender: IAccount, nonce: bigint, options: resources.RegisteringDynamicTokenInput & BaseControllerInput): Promise<Transaction>;
    awaitCompletedRegisterDynamicTokenAndSettingRoles(txHash: string): Promise<resources.EsdtOutput[]>;
    parseRegisterDynamicTokenAndSettingRoles(transactionOnNetwork: TransactionOnNetwork): resources.RegisterDynamicOutput[];
}
