"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProposeTransferExecuteContractInput = void 0;
const abi_1 = require("../abi");
const core_1 = require("../core");
const constants_1 = require("../core/constants");
const utils_codec_1 = require("../core/utils.codec");
const smartContracts_1 = require("../smartContracts");
class ProposeTransferExecuteContractInput {
    constructor(options) {
        this.multisigContract = options.multisigContract;
        this.to = options.to;
        this.gasLimit = options.gasLimit;
        this.functionCall = options.functionCall;
    }
    static async newFromTransferExecuteInput(options) {
        const transactionsFactory = new smartContracts_1.SmartContractTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: "" }),
            abi: options.abi,
        });
        const transaction = await transactionsFactory.createTransactionForExecute(core_1.Address.empty(), {
            contract: core_1.Address.empty(),
            function: options.functionName,
            gasLimit: 0n,
            arguments: options.arguments,
            nativeTransferAmount: 0n,
        });
        const functionCall = ProposeTransferExecuteContractInput.getFunctionCall(transaction);
        return new ProposeTransferExecuteContractInput({
            multisigContract: options.multisig,
            to: options.to,
            functionCall: functionCall,
            gasLimit: options.optGasLimit,
        });
    }
    static async newFromProposeAsyncCallInput(options) {
        const transactionsFactory = new smartContracts_1.SmartContractTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: "" }),
            abi: options.abi,
        });
        const transaction = await transactionsFactory.createTransactionForExecute(core_1.Address.empty(), {
            contract: core_1.Address.empty(),
            function: options.functionName,
            gasLimit: 0n,
            arguments: options.arguments,
            nativeTransferAmount: 0n,
        });
        const functionCall = ProposeTransferExecuteContractInput.getFunctionCall(transaction);
        return new ProposeTransferExecuteContractInput({
            multisigContract: options.multisig,
            to: options.to,
            functionCall: functionCall,
            gasLimit: options.optGasLimit,
        });
    }
    static getFunctionCall(transaction) {
        const functionCallParts = Buffer.from(transaction.data).toString().split(constants_1.ARGUMENTS_SEPARATOR);
        const functionName = functionCallParts[0];
        const functionArguments = functionCallParts.slice(1).map((part) => part.valueOf());
        const functionCall = [new abi_1.BytesValue(Buffer.from(utils_codec_1.utf8ToHex(functionName))), ...functionArguments];
        return functionCall;
    }
}
exports.ProposeTransferExecuteContractInput = ProposeTransferExecuteContractInput;
//# sourceMappingURL=proposeTransferExecuteContractInput.js.map