"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorsController = void 0;
const core_1 = require("../core");
const validatorsTransactionsFactory_1 = require("./validatorsTransactionsFactory");
class ValidatorsController extends core_1.BaseController {
    constructor(options) {
        super({ gasLimitEstimator: options.gasLimitEstimator });
        this.factory = new validatorsTransactionsFactory_1.ValidatorsTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: options.chainID }),
        });
    }
    async createTransactionForStaking(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForStaking(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForToppingUp(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForToppingUp(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForUnstaking(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnstaking(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForUnjailing(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnjailing(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForUnbonding(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnbonding(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForChangingRewardsAddress(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForChangingRewardsAddress(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForClaiming(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForClaiming(sender.address);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForUnstakingNodes(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnstakingNodes(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForUnstakingTokens(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnstakingTokens(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForUnbondingNodes(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnbondingNodes(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForUnbondingTokens(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnbondingTokens(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForCleaningRegisteredData(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForCleaningRegisteredData(sender.address);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForRestakingUnstakedNodes(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForRestakingUnstakedNodes(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForNewDelegationContractFromValidatorData(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForNewDelegationContractFromValidatorData(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForMergingValidatorToDelegationWithWhitelist(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForMergingValidatorToDelegationWithWhitelist(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForMergingValidatorToDelegationSameOwner(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForMergingValidatorToDelegationSameOwner(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
}
exports.ValidatorsController = ValidatorsController;
//# sourceMappingURL=validatorsController.js.map