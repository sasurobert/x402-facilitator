"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorsTransactionsFactory = void 0;
const abi_1 = require("../abi");
const address_1 = require("../core/address");
const baseFactory_1 = require("../core/baseFactory");
const constants_1 = require("../core/constants");
const transaction_1 = require("../core/transaction");
const validatorsSigner_1 = require("./validatorsSigner");
/**
 * Use this class to create validators related transactions like creating transaction for staking or adding nodes.
 */
class ValidatorsTransactionsFactory extends baseFactory_1.BaseFactory {
    constructor(options) {
        super({ config: options.config, gasLimitEstimator: options.gasLimitEstimator });
        this.config = options.config;
        this.argSerializer = new abi_1.ArgSerializer();
    }
    async createTransactionForStaking(sender, options) {
        let validators;
        if (typeof options.validatorsFile === "string") {
            validators = await validatorsSigner_1.ValidatorsSigners.newFromPem(options.validatorsFile);
        }
        else {
            validators = options.validatorsFile;
        }
        const dataParts = this.prepareDataPartsForStaking({
            nodeOperator: sender,
            validatorsFile: validators,
            rewardsAddress: options.rewardsAddress,
        });
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
            value: options.amount,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForStaking * BigInt(validators.getNumOfNodes()));
        return transaction;
    }
    prepareDataPartsForStaking(options) {
        const dataParts = ["stake"];
        const numOfNodes = options.validatorsFile.getNumOfNodes();
        const callArguments = [];
        callArguments.push(new abi_1.U32Value(numOfNodes));
        for (const signer of options.validatorsFile.getSigners()) {
            const signedMessages = signer.sign(options.nodeOperator.getPublicKey());
            callArguments.push(new abi_1.BytesValue(Buffer.from(signer.getPubkey())));
            callArguments.push(new abi_1.BytesValue(Buffer.from(signedMessages)));
        }
        if (options.rewardsAddress) {
            callArguments.push(new abi_1.AddressValue(options.rewardsAddress));
        }
        const args = this.argSerializer.valuesToStrings(callArguments);
        return dataParts.concat(args);
    }
    async createTransactionForToppingUp(sender, options) {
        const data = ["stake"];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
            value: options.amount,
        });
        this.setTransactionPayload(transaction, data);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForToppingUp);
        return transaction;
    }
    async createTransactionForUnstaking(sender, options) {
        const dataParts = ["unStake"];
        for (const key of options.publicKeys) {
            dataParts.push(key.hex());
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForUnstaking * BigInt(options.publicKeys.length));
        return transaction;
    }
    async createTransactionForUnjailing(sender, options) {
        const dataParts = ["unJail"];
        for (const key of options.publicKeys) {
            dataParts.push(key.hex());
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForUnjailing * BigInt(options.publicKeys.length));
        return transaction;
    }
    async createTransactionForUnbonding(sender, options) {
        const dataParts = ["unBond"];
        for (const key of options.publicKeys) {
            dataParts.push(key.hex());
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForUnbonding * BigInt(options.publicKeys.length));
        return transaction;
    }
    async createTransactionForChangingRewardsAddress(sender, options) {
        const dataParts = ["changeRewardAddress", options.rewardsAddress.toHex()];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForChangingRewardsAddress);
        return transaction;
    }
    async createTransactionForClaiming(sender) {
        const dataParts = ["claim"];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForClaiming);
        return transaction;
    }
    async createTransactionForUnstakingNodes(sender, options) {
        const dataParts = ["unStakeNodes"];
        for (const key of options.publicKeys) {
            dataParts.push(key.hex());
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForUnstakingNodes * BigInt(options.publicKeys.length));
        return transaction;
    }
    async createTransactionForUnstakingTokens(sender, options) {
        const dataParts = ["unStakeTokens", this.argSerializer.valuesToStrings([new abi_1.BigUIntValue(options.amount)])[0]];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForUnstakingTokens);
        return transaction;
    }
    async createTransactionForUnbondingNodes(sender, options) {
        const dataParts = ["unBondNodes"];
        for (const key of options.publicKeys) {
            dataParts.push(key.hex());
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForUnbondingNodes * BigInt(options.publicKeys.length));
        return transaction;
    }
    async createTransactionForUnbondingTokens(sender, options) {
        const dataParts = ["unBondTokens", this.argSerializer.valuesToStrings([new abi_1.BigUIntValue(options.amount)])[0]];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForUnbondingTokens);
        return transaction;
    }
    async createTransactionForCleaningRegisteredData(sender) {
        const dataParts = ["cleanRegisteredData"];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForCleaningRegisteredData);
        return transaction;
    }
    async createTransactionForRestakingUnstakedNodes(sender, options) {
        const dataParts = ["reStakeUnStakedNodes"];
        for (const key of options.publicKeys) {
            dataParts.push(key.hex());
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.STAKING_SMART_CONTRACT_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForUnstakingNodes * BigInt(options.publicKeys.length));
        return transaction;
    }
    async createTransactionForNewDelegationContractFromValidatorData(sender, options) {
        const dataParts = [
            "makeNewContractFromValidatorData",
            ...this.argSerializer.valuesToStrings([new abi_1.BigUIntValue(options.maxCap), new abi_1.BigUIntValue(options.fee)]),
        ];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.DELEGATION_MANAGER_SC_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForCreatingDelegationContractFromValidator);
        return transaction;
    }
    async createTransactionForMergingValidatorToDelegationWithWhitelist(sender, options) {
        const dataParts = [
            "mergeValidatorToDelegationWithWhitelist",
            this.argSerializer.valuesToStrings([new abi_1.AddressValue(options.delegationAddress)])[0],
        ];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.DELEGATION_MANAGER_SC_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForWhitelistForMerge);
        return transaction;
    }
    async createTransactionForMergingValidatorToDelegationSameOwner(sender, options) {
        const dataParts = [
            "mergeValidatorToDelegationSameOwner",
            this.argSerializer.valuesToStrings([new abi_1.AddressValue(options.delegationAddress)])[0],
        ];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: address_1.Address.newFromHex(constants_1.DELEGATION_MANAGER_SC_ADDRESS_HEX, this.config.addressHrp),
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForMergingValidatorToDelegation);
        return transaction;
    }
}
exports.ValidatorsTransactionsFactory = ValidatorsTransactionsFactory;
//# sourceMappingURL=validatorsTransactionsFactory.js.map