"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyNetworkProvider = void 0;
const axios_1 = __importDefault(require("axios"));
const accounts_1 = require("./accounts");
const config_1 = require("./config");
const constants_1 = require("./constants");
const contractQueryRequest_1 = require("./contractQueryRequest");
const contractQueryResponse_1 = require("./contractQueryResponse");
const errors_1 = require("./errors");
const networkConfig_1 = require("./networkConfig");
const networkStatus_1 = require("./networkStatus");
const tokenDefinitions_1 = require("./tokenDefinitions");
const tokens_1 = require("./tokens");
const transactions_1 = require("./transactions");
const transactionStatus_1 = require("./transactionStatus");
const userAgent_1 = require("./userAgent");
// TODO: Find & remove duplicate code between "ProxyNetworkProvider" and "ApiNetworkProvider".
class ProxyNetworkProvider {
    constructor(url, config) {
        this.userAgentPrefix = `${constants_1.BaseUserAgent}/proxy`;
        this.url = url;
        this.config = Object.assign(Object.assign({}, config_1.defaultAxiosConfig), config);
        userAgent_1.extendUserAgentIfBackend(this.userAgentPrefix, this.config);
    }
    getNetworkConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric("network/config");
            let networkConfig = networkConfig_1.NetworkConfig.fromHttpResponse(response.config);
            return networkConfig;
        });
    }
    getNetworkStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric("network/status/4294967295");
            let networkStatus = networkStatus_1.NetworkStatus.fromHttpResponse(response.status);
            return networkStatus;
        });
    }
    getNetworkStakeStatistics() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Implement wrt.:
            // https://github.com/multiversx/mx-api-service/blob/main/src/endpoints/stake/stake.service.ts
            throw new Error("Method not implemented.");
        });
    }
    getNetworkGeneralStatistics() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Implement wrt. (full implementation may not be possible):
            // https://github.com/multiversx/mx-api-service/blob/main/src/endpoints/network/network.service.ts
            throw new Error("Method not implemented.");
        });
    }
    getAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`address/${address.bech32()}`);
            let account = accounts_1.AccountOnNetwork.fromHttpResponse(response.account);
            return account;
        });
    }
    getGuardianData(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.doGetGeneric(`address/${address.bech32()}/guardian-data`);
            const accountGuardian = accounts_1.GuardianData.fromHttpResponse(response.guardianData);
            return accountGuardian;
        });
    }
    getFungibleTokensOfAccount(address, _pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `address/${address.bech32()}/esdt`;
            let response = yield this.doGetGeneric(url);
            let responseItems = Object.values(response.esdts);
            // Skip NFTs / SFTs.
            let responseItemsFiltered = responseItems.filter(item => !item.nonce);
            let tokens = responseItemsFiltered.map(item => tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(item));
            // TODO: Fix sorting
            tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
            return tokens;
        });
    }
    getNonFungibleTokensOfAccount(address, _pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `address/${address.bech32()}/esdt`;
            let response = yield this.doGetGeneric(url);
            let responseItems = Object.values(response.esdts);
            // Skip fungible tokens.
            let responseItemsFiltered = responseItems.filter(item => item.nonce >= 0);
            let tokens = responseItemsFiltered.map(item => tokens_1.NonFungibleTokenOfAccountOnNetwork.fromProxyHttpResponse(item));
            // TODO: Fix sorting
            tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
            return tokens;
        });
    }
    getFungibleTokenOfAccount(address, tokenIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`address/${address.bech32()}/esdt/${tokenIdentifier}`);
            let tokenData = tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(response.tokenData);
            return tokenData;
        });
    }
    getNonFungibleTokenOfAccount(address, collection, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`address/${address.bech32()}/nft/${collection}/nonce/${nonce.valueOf()}`);
            let tokenData = tokens_1.NonFungibleTokenOfAccountOnNetwork.fromProxyHttpResponseByNonce(response.tokenData);
            return tokenData;
        });
    }
    getTransaction(txHash, _) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.buildUrlWithQueryParameters(`transaction/${txHash}`, { withResults: "true" });
            const [data, status] = yield Promise.all([this.doGetGeneric(url), this.getTransactionStatus(txHash)]);
            return transactions_1.TransactionOnNetwork.fromProxyHttpResponse(txHash, data.transaction, status);
        });
    }
    getTransactionStatus(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`transaction/${txHash}/process-status`);
            let status = new transactionStatus_1.TransactionStatus(response.status);
            return status;
        });
    }
    sendTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = transactions_1.prepareTransactionForBroadcasting(tx);
            const response = yield this.doPostGeneric("transaction/send", transaction);
            return response.txHash;
        });
    }
    sendTransactions(txs) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (txs).map((tx) => transactions_1.prepareTransactionForBroadcasting(tx));
            const response = yield this.doPostGeneric("transaction/send-multiple", data);
            const hashes = Array(txs.length).fill(null);
            for (let i = 0; i < txs.length; i++) {
                hashes[i] = response.txsHashes[i.toString()] || null;
            }
            return hashes;
        });
    }
    simulateTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = transactions_1.prepareTransactionForBroadcasting(tx);
            const response = yield this.doPostGeneric("transaction/simulate", transaction);
            return response;
        });
    }
    queryContract(query) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let request = new contractQueryRequest_1.ContractQueryRequest(query).toHttpRequest();
                let response = yield this.doPostGeneric("vm-values/query", request);
                return contractQueryResponse_1.ContractQueryResponse.fromHttpResponse(response.data);
            }
            catch (error) {
                throw new errors_1.ErrContractQuery(error);
            }
        });
    }
    getDefinitionOfFungibleToken(tokenIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let properties = yield this.getTokenProperties(tokenIdentifier);
            let definition = tokenDefinitions_1.DefinitionOfFungibleTokenOnNetwork.fromResponseOfGetTokenProperties(tokenIdentifier, properties);
            return definition;
        });
    }
    getTokenProperties(identifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let encodedIdentifier = Buffer.from(identifier).toString("hex");
            let queryResponse = yield this.queryContract({
                address: constants_1.EsdtContractAddress,
                func: "getTokenProperties",
                getEncodedArguments: () => [encodedIdentifier]
            });
            let properties = queryResponse.getReturnDataParts();
            return properties;
        });
    }
    getDefinitionOfTokenCollection(collection) {
        return __awaiter(this, void 0, void 0, function* () {
            let properties = yield this.getTokenProperties(collection);
            let definition = tokenDefinitions_1.DefinitionOfTokenCollectionOnNetwork.fromResponseOfGetTokenProperties(collection, properties);
            return definition;
        });
    }
    getNonFungibleToken(_collection, _nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Method not implemented.");
        });
    }
    doGetGeneric(resourceUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGet(resourceUrl);
            return response;
        });
    }
    doPostGeneric(resourceUrl, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doPost(resourceUrl, payload);
            return response;
        });
    }
    doGet(resourceUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.url}/${resourceUrl}`;
            try {
                let response = yield axios_1.default.get(url, this.config);
                let payload = response.data.data;
                return payload;
            }
            catch (error) {
                this.handleApiError(error, resourceUrl);
            }
        });
    }
    doPost(resourceUrl, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.url}/${resourceUrl}`;
            try {
                let response = yield axios_1.default.post(url, payload, Object.assign(Object.assign({}, this.config), { headers: Object.assign({ "Content-Type": "application/json" }, this.config.headers) }));
                let responsePayload = response.data.data;
                return responsePayload;
            }
            catch (error) {
                this.handleApiError(error, resourceUrl);
            }
        });
    }
    buildUrlWithQueryParameters(endpoint, params) {
        let searchParams = new URLSearchParams();
        for (let [key, value] of Object.entries(params)) {
            if (value) {
                searchParams.append(key, value);
            }
        }
        return `${endpoint}?${searchParams.toString()}`;
    }
    handleApiError(error, resourceUrl) {
        if (!error.response) {
            throw new errors_1.ErrNetworkProvider(resourceUrl, error.toString(), error);
        }
        const errorData = error.response.data;
        const originalErrorMessage = errorData.message || errorData.error || JSON.stringify(errorData);
        throw new errors_1.ErrNetworkProvider(resourceUrl, originalErrorMessage, error);
    }
}
exports.ProxyNetworkProvider = ProxyNetworkProvider;
//# sourceMappingURL=proxyNetworkProvider.js.map