"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigController = void 0;
const core_1 = require("../core");
const smartContracts_1 = require("../smartContracts");
const multisigTransactionsFactory_1 = require("./multisigTransactionsFactory");
const multisigTransactionsOutcomeParser_1 = require("./multisigTransactionsOutcomeParser");
const resources = __importStar(require("./resources"));
class MultisigController extends core_1.BaseController {
    constructor(options) {
        super({ gasLimitEstimator: options.gasLimitEstimator });
        this.mapResponseToAction = (responseData) => {
            const { name, fields } = responseData;
            switch (name) {
                case resources.MultisigActionEnum.Nothing:
                    return new resources.MultisigAction();
                case resources.MultisigActionEnum.AddBoardMember:
                    return new resources.AddBoardMember(fields[0]);
                case resources.MultisigActionEnum.AddProposer:
                    return new resources.AddProposer(fields[0]);
                case resources.MultisigActionEnum.RemoveUser:
                    return new resources.RemoveUser(fields[0]);
                case resources.MultisigActionEnum.ChangeQuorum:
                    return new resources.ChangeQuorum(fields[0]);
                case resources.MultisigActionEnum.SendTransferExecuteEgld:
                    return new resources.SendTransferExecuteEgld(fields[0]);
                case resources.MultisigActionEnum.SendTransferExecuteEsdt:
                    return new resources.SendTransferExecuteEsdt(fields[0]);
                case resources.MultisigActionEnum.SendAsyncCall:
                    return new resources.SendAsyncCall(fields[0]);
                case resources.MultisigActionEnum.SCDeployFromSource:
                    return new resources.SCDeployFromSource(fields);
                case resources.MultisigActionEnum.SCUpgradeFromSource:
                    return new resources.SCUpgradeFromSource(fields);
                default:
                    throw new Error(`Unknown action type: ${name}`);
            }
        };
        this.transactionAwaiter = new core_1.TransactionWatcher(options.networkProvider);
        this.multisigFactory = new multisigTransactionsFactory_1.MultisigTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: options.chainID }),
            abi: options.abi,
        });
        this.multisigParser = new multisigTransactionsOutcomeParser_1.MultisigTransactionsOutcomeParser({ abi: options.abi });
        this.smartContractController = new smartContracts_1.SmartContractController({
            chainID: options.chainID,
            networkProvider: options.networkProvider,
            abi: options.abi,
        });
    }
    /**
     * Creates a transaction for deploying a new multisig contract
     */
    async createTransactionForDeploy(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForDeploy(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        await this.setTransactionGasOptions(transaction, options);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    parseDeploy(transactionOnNetwork) {
        return this.multisigParser.parseDeploy(transactionOnNetwork);
    }
    async awaitCompletedDeploy(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseDeploy(transaction);
    }
    /**
     * Gets quorum for specific multisig
     */
    async getQuorum(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getQuorum",
            arguments: [],
        });
        return Number(value.toString());
    }
    /**
     * Gets number of board members for specific multisig
     */
    async getNumBoardMembers(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getNumBoardMembers",
            arguments: [],
        });
        return Number(value.toString());
    }
    /**
     * Gets number of groups for specific multisig
     */
    async getNumGroups(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getNumGroups",
            arguments: [],
        });
        return Number(value.toString());
    }
    /**
     * Gets number of proposers for specific multisig
     */
    async getNumProposers(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getNumProposers",
            arguments: [],
        });
        return Number(value.toString());
    }
    /**
     * Gets action group for specific multisig
     */
    async getActionGroup(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getActionGroup",
            arguments: [options.groupId],
        });
        return value.map((n) => Number(n.toString()));
    }
    /**
     * Gets last group action id specific multisig
     */
    async getLastGroupActionId(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getLastGroupActionId",
            arguments: [],
        });
        return Number(value.toString());
    }
    /**
     * Gets last action index specific multisig
     */
    async getActionLastIndex(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getActionLastIndex",
            arguments: [],
        });
        return Number(value.toString());
    }
    /**
     * Returns `true` (`1`) if the user has signed the action.
     * Does not check whether or not the user is still a board member and the signature valid.
     */
    async hasSignedAction(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "signed",
            arguments: [core_1.Address.newFromBech32(options.userAddress), options.actionId],
        });
        return value;
    }
    /**
     * Returns `true` (`1`) if `getActionValidSignerCount >= getQuorum`.
     */
    async quorumReached(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "quorumReached",
            arguments: [options.actionId],
        });
        return value;
    }
    /**
     * Lists all users that can sign actions.
     */
    async getAllBoardMembers(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getAllBoardMembers",
            arguments: [],
        });
        return value.map((address) => address?.toBech32());
    }
    /**
     * Lists all proposers that are not board members.
     */
    async getAllProposers(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getAllProposers",
            arguments: [],
        });
        return value.map((address) => address?.toBech32());
    }
    /**
     *  "Indicates user rights.",
     * `0` = no rights,",
     * `1` = can propose, but not sign,
     * `2` = can propose and sign.
     */
    async getUserRole(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "userRole",
            arguments: [core_1.Address.newFromBech32(options.userAddress)],
        });
        const userRole = value.valueOf().name;
        return resources.UserRoleEnum[userRole];
    }
    /**
     * Serialized action data of an action with index.
     */
    async getActionData(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getActionData",
            arguments: [options.actionId],
        });
        const result = this.mapResponseToAction(value.valueOf());
        return result;
    }
    /**
     * Gets all pending actions.
     */
    async getPendingActionFullInfo(options) {
        const [actions] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getPendingActionFullInfo",
            arguments: [],
        });
        const result = [];
        for (let action = 0; action < actions.length; action++) {
            const element = actions[action];
            result.push({
                actionId: Number(element.action_id.toString()),
                groupId: Number(element.group_id.toString()),
                actionData: this.mapResponseToAction(element.action_data.valueOf()),
                signers: element.signers.map((address) => new core_1.Address(address)),
            });
        }
        return result;
    }
    /**
     * Gets addresses of all users who signed an action.
     * Does not check if those users are still board members or not, so the result may contain invalid signers.
     */
    async getActionSigners(options) {
        const response = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getActionSigners",
            arguments: [options.actionId],
        });
        const addresses = response.valueOf();
        return addresses[0];
    }
    /**
     * Gets addresses of all users who signed an action and are still board members.
     * All these signatures are currently valid.
     */
    async getActionSignerCount(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getActionSignerCount",
            arguments: [options.actionId],
        });
        return value;
    }
    /**
     * Gets addresses of all users who signed an action and are still board members.
     * All these signatures are currently valid.
     */
    async getActionValidSignerCount(options) {
        const [value] = await this.smartContractController.query({
            contract: core_1.Address.newFromBech32(options.multisigAddress),
            function: "getActionValidSignerCount",
            arguments: [options.actionId],
        });
        return Number(value.toString());
    }
    /**
     * Creates a transaction for proposing to add a board member
     */
    async createTransactionForProposeAddBoardMember(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeAddBoardMember(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for proposing to add a proposer
     */
    async createTransactionForProposeAddProposer(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeAddProposer(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for proposing to remove a user
     */
    async createTransactionForProposeRemoveUser(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeRemoveUser(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for proposing to change quorum
     */
    async createTransactionForProposeChangeQuorum(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeChangeQuorum(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    parseProposeAction(transaction) {
        return this.multisigParser.parseProposeAction(transaction);
    }
    async awaitCompletedProposeAction(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.multisigParser.parseProposeAction(transaction);
    }
    /**
     * Creates a transaction for signing an action
     */
    async createTransactionForSignAction(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForSignAction(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for performing an action
     */
    async createTransactionForPerformAction(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForPerformAction(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    parsePerformAction(transaction) {
        return this.multisigParser.parsePerformAction(transaction);
    }
    async awaitCompletedPerformAction(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.multisigParser.parsePerformAction(transaction);
    }
    /**
     * Creates a transaction for unsigning an action
     */
    async createTransactionForUnsignAction(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForUnsign(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for discarding an action
     */
    async createTransactionForDiscardAction(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForDiscardAction(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for deposit native token or tokens
     */
    async createTransactionForDeposit(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForDeposit(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for proposing to transfer EGLD and execute a smart contract call
     */
    async createTransactionForProposeTransferExecute(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeTransferExecute(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for proposing to transfer ESDT tokens and execute a smart contract call
     */
    async createTransactionForProposeTransferExecuteEsdt(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeTransferExecuteEsdt(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for proposing an async call to another contract
     */
    async createTransactionForProposeAsyncCall(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeAsyncCall(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for proposing to deploy a smart contract from source
     */
    async createTransactionForProposeContractDeployFromSource(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeContractDeployFromSource(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for proposing to upgrade a smart contract from source
     */
    async createTransactionForProposeContractUpgradeFromSource(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForProposeContractUpgradeFromSource(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for signing a batch of actions
     */
    async createTransactionForSignBatch(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForSignBatch(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for signing and performing an action in one step
     */
    async createTransactionForSignAndPerform(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForSignAndPerform(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for unsigning for outdated board members
     */
    async createTransactionForUnsignForOutdatedBoardMembers(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForUnsignForOutdatedBoardMembers(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for performing a batch of actions
     */
    async createTransactionForPerformBatch(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForPerformBatch(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    /**
     * Creates a transaction for discarding a batch of actions
     */
    async createTransactionForDiscardBatch(sender, nonce, options) {
        options.gasLimit = options.gasLimit ? options.gasLimit : 0n;
        const transaction = await this.multisigFactory.createTransactionForDiscardBatch(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
}
exports.MultisigController = MultisigController;
//# sourceMappingURL=multisigController.js.map