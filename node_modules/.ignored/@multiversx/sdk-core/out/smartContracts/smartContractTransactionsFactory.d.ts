import { Abi, EndpointDefinition } from "../abi";
import { Address, IGasLimitEstimator } from "../core";
import { BaseFactory } from "../core/baseFactory";
import { Transaction } from "../core/transaction";
import * as resources from "./resources";
interface IConfig {
    chainID: string;
    addressHrp: string;
    minGasLimit: bigint;
    gasLimitPerByte: bigint;
    gasLimitClaimDeveloperRewards: bigint;
    gasLimitChangeOwnerAddress: bigint;
}
/**
 * Use this class to create transactions to deploy, call or upgrade a smart contract.
 */
export declare class SmartContractTransactionsFactory extends BaseFactory {
    private readonly config;
    private readonly abi?;
    private readonly tokenComputer;
    private readonly dataArgsBuilder;
    private readonly contractDeployAddress;
    constructor(options: {
        config: IConfig;
        abi?: Abi;
        gasLimitEstimator?: IGasLimitEstimator;
    });
    createTransactionForDeploy(sender: Address, options: resources.ContractDeployInput): Promise<Transaction>;
    createTransactionForExecute(sender: Address, options: resources.ContractExecuteInput): Promise<Transaction>;
    createTransactionForUpgrade(sender: Address, options: resources.ContractUpgradeInput): Promise<Transaction>;
    private getEndpointForUpgrade;
    createTransactionForClaimingDeveloperRewards(options: {
        sender: Address;
        contract: Address;
        gasLimit?: bigint;
    }): Promise<Transaction>;
    createTransactionForChangingOwnerAddress(options: {
        sender: Address;
        contract: Address;
        newOwner: Address;
        gasLimit?: bigint;
    }): Promise<Transaction>;
    protected argsToDataParts(args: any[], endpoint?: EndpointDefinition): string[];
    private areArgsBuffers;
    private areArgsOfTypedValue;
}
export {};
