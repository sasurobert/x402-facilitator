"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainnetEntrypoint = exports.DevnetEntrypoint = exports.TestnetEntrypoint = exports.NetworkEntrypoint = void 0;
const accountManagement_1 = require("../accountManagement");
const accounts_1 = require("../accounts");
const core_1 = require("../core");
const delegation_1 = require("../delegation");
const gasEstimator_1 = require("../gasEstimator");
const governance_1 = require("../governance");
const multisig_1 = require("../multisig");
const multisigController_1 = require("../multisig/multisigController");
const networkProviders_1 = require("../networkProviders");
const smartContracts_1 = require("../smartContracts");
const smartContractController_1 = require("../smartContracts/smartContractController");
const tokenManagement_1 = require("../tokenManagement");
const transfers_1 = require("../transfers");
const validators_1 = require("../validators");
const validatorsController_1 = require("../validators/validatorsController");
const wallet_1 = require("../wallet");
const config_1 = require("./config");
class NetworkEntrypoint {
    constructor(options) {
        const networkProviderConfig = {
            ...(options.networkProviderConfig ?? {}),
            ...(options.clientName && { clientName: options.clientName }),
        };
        if (options.networkProviderKind === "proxy") {
            this.networkProvider = new networkProviders_1.ProxyNetworkProvider(options.networkProviderUrl, networkProviderConfig);
        }
        else if (options.networkProviderKind === "api") {
            this.networkProvider = new networkProviders_1.ApiNetworkProvider(options.networkProviderUrl, networkProviderConfig);
        }
        else {
            throw new core_1.ErrInvalidNetworkProviderKind();
        }
        this.chainId = options.chainId;
        this.withGasLimitEstimator = options.withGasLimitEstimator;
        this.gasLimitMultiplier = options.gasLimitMultiplier;
    }
    /**
     * Creates a new Account by generating a new secret key and instantiating an UserSigner
     */
    async createAccount() {
        const secretKey = wallet_1.UserSecretKey.generate();
        return new accounts_1.Account(secretKey);
    }
    /**
     * Calls a faucet
     */
    async getAirdrop(_address) {
        throw new Error("Not implemented");
    }
    async signTransaction(transaction, account) {
        transaction.signature = await account.signTransaction(transaction);
    }
    /**
     * Verifies if the signature field is valid
     * @param transaction
     * @param account
     */
    async verifyTransactionSignature(transaction, account) {
        return await account.verifyTransactionSignature(transaction, transaction.signature);
    }
    /**
     * Verifies if message signature is valid
     * @param message
     * @param account
     */
    async verifyMessageSignature(message, account) {
        if (!message.address) {
            throw new Error("`address` property of Message is not set");
        }
        if (!message.signature) {
            throw new Error("`signature` property of Message is not set");
        }
        return await account.verifyMessageSignature(message, message.signature);
    }
    /**
     * Fetches the account nonce from the network.
     * @param address
     */
    async recallAccountNonce(address) {
        return (await this.networkProvider.getAccount(address)).nonce;
    }
    /**
     * Function of the network provider, promoted to the entrypoint.
     * @param transactions
     */
    sendTransactions(transactions) {
        return this.networkProvider.sendTransactions(transactions);
    }
    /**
     * Function of the network provider, promoted to the entrypoint.
     * @param transaction
     */
    sendTransaction(transaction) {
        return this.networkProvider.sendTransaction(transaction);
    }
    /**
     * Generic function to await a transaction on the network.
     * @param txHash
     */
    async awaitCompletedTransaction(txHash) {
        const transactionAwaiter = new core_1.TransactionWatcher(this.networkProvider);
        return transactionAwaiter.awaitCompleted(txHash);
    }
    getTransaction(txHash) {
        return this.networkProvider.getTransaction(txHash);
    }
    /**
     * Access to the underlying network provider.
     */
    createNetworkProvider() {
        return this.networkProvider;
    }
    createGasLimitEstimator() {
        return new gasEstimator_1.GasLimitEstimator({
            networkProvider: this.networkProvider,
            gasMultiplier: this.gasLimitMultiplier,
        });
    }
    createDelegationController() {
        return new delegation_1.DelegationController({
            chainID: this.chainId,
            networkProvider: this.networkProvider,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createDelegationTransactionsFactory() {
        return new delegation_1.DelegationTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createAccountController() {
        return new accountManagement_1.AccountController({
            chainID: this.chainId,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createAccountTransactionsFactory() {
        return new accountManagement_1.AccountTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createSmartContractController(abi) {
        return new smartContractController_1.SmartContractController({
            chainID: this.chainId,
            networkProvider: this.networkProvider,
            abi,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createSmartContractTransactionsFactory(abi) {
        return new smartContracts_1.SmartContractTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            abi: abi,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createTokenManagementController() {
        return new tokenManagement_1.TokenManagementController({
            chainID: this.chainId,
            networkProvider: this.networkProvider,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createTokenManagementTransactionsFactory() {
        return new tokenManagement_1.TokenManagementTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createTransfersController() {
        return new transfers_1.TransfersController({
            chainID: this.chainId,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createTransfersTransactionsFactory() {
        return new transfers_1.TransferTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createMultisigController(abi) {
        return new multisigController_1.MultisigController({
            chainID: this.chainId,
            networkProvider: this.networkProvider,
            abi: abi,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createMultisigTransactionsFactory(abi) {
        return new multisig_1.MultisigTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            abi: abi,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createGovernanceController() {
        return new governance_1.GovernanceController({
            chainID: this.chainId,
            networkProvider: this.networkProvider,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createGovernanceTransactionsFactory() {
        return new governance_1.GovernanceTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createValidatorsController() {
        return new validatorsController_1.ValidatorsController({
            chainID: this.chainId,
            networkProvider: this.networkProvider,
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
    createValidatorsTransactionsFactory() {
        return new validators_1.ValidatorsTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            gasLimitEstimator: this.withGasLimitEstimator ? this.createGasLimitEstimator() : undefined,
        });
    }
}
exports.NetworkEntrypoint = NetworkEntrypoint;
class TestnetEntrypoint extends NetworkEntrypoint {
    constructor(options) {
        const entrypointConfig = new config_1.TestnetEntrypointConfig();
        options = options || {};
        super({
            networkProviderUrl: options.url || entrypointConfig.networkProviderUrl,
            networkProviderKind: options.kind || entrypointConfig.networkProviderKind,
            networkProviderConfig: options.networkProviderConfig,
            chainId: entrypointConfig.chainId,
            clientName: options.clientName,
            withGasLimitEstimator: options.withGasLimitEstimator,
            gasLimitMultiplier: options.gasLimitMultiplier,
        });
    }
}
exports.TestnetEntrypoint = TestnetEntrypoint;
class DevnetEntrypoint extends NetworkEntrypoint {
    constructor(options) {
        const entrypointConfig = new config_1.DevnetEntrypointConfig();
        options = options || {};
        super({
            networkProviderUrl: options.url || entrypointConfig.networkProviderUrl,
            networkProviderKind: options.kind || entrypointConfig.networkProviderKind,
            networkProviderConfig: options.networkProviderConfig,
            chainId: entrypointConfig.chainId,
            clientName: options.clientName,
            withGasLimitEstimator: options.withGasLimitEstimator,
            gasLimitMultiplier: options.gasLimitMultiplier,
        });
    }
}
exports.DevnetEntrypoint = DevnetEntrypoint;
class MainnetEntrypoint extends NetworkEntrypoint {
    constructor(options) {
        const entrypointConfig = new config_1.MainnetEntrypointConfig();
        options = options || {};
        super({
            networkProviderUrl: options.url || entrypointConfig.networkProviderUrl,
            networkProviderKind: options.kind || entrypointConfig.networkProviderKind,
            networkProviderConfig: options.networkProviderConfig,
            chainId: entrypointConfig.chainId,
            clientName: options.clientName,
            withGasLimitEstimator: options.withGasLimitEstimator,
            gasLimitMultiplier: options.gasLimitMultiplier,
        });
    }
}
exports.MainnetEntrypoint = MainnetEntrypoint;
//# sourceMappingURL=entrypoints.js.map