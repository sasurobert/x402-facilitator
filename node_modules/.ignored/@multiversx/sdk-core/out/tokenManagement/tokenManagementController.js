"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenManagementController = void 0;
const core_1 = require("../core");
const transactionsOutcomeParsers_1 = require("../transactionsOutcomeParsers");
const tokenManagementTransactionsFactory_1 = require("./tokenManagementTransactionsFactory");
class TokenManagementController extends core_1.BaseController {
    constructor(options) {
        super({ gasLimitEstimator: options.gasLimitEstimator });
        this.factory = new tokenManagementTransactionsFactory_1.TokenManagementTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: options.chainID }),
        });
        this.transactionAwaiter = new core_1.TransactionWatcher(options.networkProvider);
        this.parser = new transactionsOutcomeParsers_1.TokenManagementTransactionsOutcomeParser();
    }
    async createTransactionForIssuingFungible(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForIssuingFungible(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedIssueFungible(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseIssueFungible(transaction);
    }
    parseIssueFungible(transactionOnNetwork) {
        return this.parser.parseIssueFungible(transactionOnNetwork);
    }
    async createTransactionForIssuingSemiFungible(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForIssuingSemiFungible(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedIssueSemiFungible(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseIssueSemiFungible(transaction);
    }
    parseIssueSemiFungible(transactionOnNetwork) {
        return this.parser.parseIssueSemiFungible(transactionOnNetwork);
    }
    async createTransactionForIssuingNonFungible(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForIssuingNonFungible(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedIssueNonFungible(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseIssueNonFungible(transaction);
    }
    parseIssueNonFungible(transactionOnNetwork) {
        return this.parser.parseIssueNonFungible(transactionOnNetwork);
    }
    async createTransactionForRegisteringMetaEsdt(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForRegisteringMetaESDT(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedRegisterMetaEsdt(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseRegisterMetaEsdt(transaction);
    }
    parseRegisterMetaEsdt(transactionOnNetwork) {
        return this.parser.parseRegisterMetaEsdt(transactionOnNetwork);
    }
    async createTransactionForRegisteringAndSettingRoles(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForRegisteringAndSettingRoles(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedRegisterAndSettingRoles(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseRegisterAndSetAllRoles(transaction);
    }
    parseRegisterAndSetAllRoles(transactionOnNetwork) {
        return this.parser.parseRegisterMetaEsdt(transactionOnNetwork);
    }
    async createTransactionForSetBurnRoleGlobally(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForSettingBurnRoleGlobally(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedSetBurnRoleGlobally(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseSetBurnRoleGlobally(transaction);
    }
    parseSetBurnRoleGlobally(transactionOnNetwork) {
        return this.parser.parseSetBurnRoleGlobally(transactionOnNetwork);
    }
    async createTransactionForUnsettingBurnRoleGlobally(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnsettingBurnRoleGlobally(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedUnsetBurnRoleGlobally(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseUnsetBurnRoleGlobally(transaction);
    }
    parseUnsetBurnRoleGlobally(transactionOnNetwork) {
        return this.parser.parseUnsetBurnRoleGlobally(transactionOnNetwork);
    }
    async createTransactionForSettingSpecialRoleOnFungibleToken(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForSettingSpecialRoleOnFungibleToken(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedSetSpecialRoleOnFungibleToken(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseSetSpecialRoleOnFungible(transaction);
    }
    parseSetSpecialRoleOnFungible(transactionOnNetwork) {
        return this.parser.parseSetSpecialRole(transactionOnNetwork);
    }
    async createTransactionForUnsettingSpecialRoleOnFungibleToken(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnsettingSpecialRoleOnFungibleToken(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForSettingSpecialRoleOnSemiFungibleToken(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForSettingSpecialRoleOnSemiFungibleToken(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedSetSpecialRoleOnSemiFungibleToken(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseSetSpecialRoleOnSemiFungibleToken(transaction);
    }
    parseSetSpecialRoleOnSemiFungibleToken(transactionOnNetwork) {
        return this.parser.parseSetSpecialRole(transactionOnNetwork);
    }
    async createTransactionForUnsettingSpecialRoleOnSemiFungibleToken(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnsettingSpecialRoleOnSemiFungibleToken(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForSettingSpecialRoleOnMetaESDT(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForSettingSpecialRoleOnMetaESDT(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedSetSpecialRoleOnMetaESDTToken(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseSetSpecialRoleOnSemiFungibleToken(transaction);
    }
    parseSetSpecialRoleOnMetaESDTToken(transactionOnNetwork) {
        return this.parser.parseSetSpecialRole(transactionOnNetwork);
    }
    async createTransactionForUnsettingSpecialRoleOnMetaESDT(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnsettingSpecialRoleOnMetaESDT(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForSettingSpecialRoleOnNonFungibleToken(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForSettingSpecialRoleOnNonFungibleToken(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedSetSpecialRoleOnNonFungibleToken(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseSetSpecialRoleOnNonFungibleToken(transaction);
    }
    parseSetSpecialRoleOnNonFungibleToken(transactionOnNetwork) {
        return this.parser.parseSetSpecialRole(transactionOnNetwork);
    }
    async createTransactionForUnsettingSpecialRoleOnNonFungibleToken(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnsettingSpecialRoleOnNonFungibleToken(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async createTransactionForCreatingNft(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForCreatingNFT(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedCreateNft(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseNftCreate(transaction);
    }
    parseNftCreate(transactionOnNetwork) {
        return this.parser.parseNftCreate(transactionOnNetwork);
    }
    async createTransactionForPausing(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForPausing(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedPause(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parsePause(transaction);
    }
    parsePause(transactionOnNetwork) {
        return this.parser.parsePause(transactionOnNetwork);
    }
    async createTransactionForUnpausing(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnpausing(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedUnpause(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseUnpause(transaction);
    }
    parseUnpause(transactionOnNetwork) {
        return this.parser.parseUnpause(transactionOnNetwork);
    }
    async createTransactionForFreezing(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForFreezing(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedFreeze(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseFreeze(transaction);
    }
    parseFreeze(transactionOnNetwork) {
        return this.parser.parseFreeze(transactionOnNetwork);
    }
    async createTransactionForUnFreezing(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUnfreezing(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedUnfreeze(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseUnfreeze(transaction);
    }
    parseUnfreeze(transactionOnNetwork) {
        return this.parser.parseUnfreeze(transactionOnNetwork);
    }
    async createTransactionForWiping(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForWiping(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedWipe(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parser.parseWipe(transaction);
    }
    parseWipe(transactionOnNetwork) {
        return this.parser.parseWipe(transactionOnNetwork);
    }
    async createTransactionForLocaMinting(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForLocalMint(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedLocalMint(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseLocalMint(transaction);
    }
    parseLocalMint(transactionOnNetwork) {
        return this.parser.parseLocalMint(transactionOnNetwork);
    }
    async createTransactionForLocalBurning(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForLocalBurning(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompleteLocalBurn(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseLocalBurn(transaction);
    }
    parseLocalBurn(transactionOnNetwork) {
        return this.parser.parseLocalBurn(transactionOnNetwork);
    }
    async createTransactionForUpdatingAttributes(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUpdatingAttributes(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedUpdateAttributes(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseUpdateAttributes(transaction);
    }
    parseUpdateAttributes(transactionOnNetwork) {
        return this.parser.parseUpdateAttributes(transactionOnNetwork);
    }
    async createTransactionForAddingQuantity(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForAddingQuantity(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedAddQuantity(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseAddQuantity(transaction);
    }
    parseAddQuantity(transactionOnNetwork) {
        return this.parser.parseAddQuantity(transactionOnNetwork);
    }
    async createTransactionForBurningQuantity(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForBurningQuantity(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedBurnQuantity(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseBurnQuantity(transaction);
    }
    parseBurnQuantity(transactionOnNetwork) {
        return this.parser.parseBurnQuantity(transactionOnNetwork);
    }
    async createTransactionForModifyingRoyalties(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForModifyingRoyalties(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedModifyRoyalties(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseModifyRoyalties(transaction);
    }
    parseModifyRoyalties(transactionOnNetwork) {
        return this.parser.parseModifyRoyalties(transactionOnNetwork);
    }
    async createTransactionForSettingNewUris(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForSettingNewUris(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedSetNewUris(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseSetNewUris(transaction);
    }
    parseSetNewUris(transactionOnNetwork) {
        return this.parser.parseSetNewUris(transactionOnNetwork);
    }
    async createTransactionForModifyingCreator(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForModifyingCreator(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedModifyCreator(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseModifyCreator(transaction);
    }
    parseModifyCreator(transactionOnNetwork) {
        return this.parser.parseModifyCreator(transactionOnNetwork);
    }
    async createTransactionForUpdatingMetadata(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForModifyingCreator(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedUpdateMetadata(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseUpdateMetadata(transaction);
    }
    parseUpdateMetadata(transactionOnNetwork) {
        return this.parser.parseUpdateMetadata(transactionOnNetwork);
    }
    async createTransactionForMetadataRecreate(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForMetadataRecreate(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedMetadataRecreate(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseMetadataRecreate(transaction);
    }
    parseMetadataRecreate(transactionOnNetwork) {
        return this.parser.parseMetadataRecreate(transactionOnNetwork);
    }
    async createTransactionForChangingTokenToDynamic(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForChangingTokenToDynamic(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedChangeTokenToDynamic(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseChangeTokenToDynamic(transaction);
    }
    parseChangeTokenToDynamic(transactionOnNetwork) {
        return this.parser.parseChangeTokenToDynamic(transactionOnNetwork);
    }
    async createTransactionForUpdatingTokenId(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForUpdatingTokenId(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedUpdateTokenId(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return transaction;
    }
    async createTransactionForRegisteringDynamicToken(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForRegisteringDynamicToken(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedRegisterDynamicToken(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseRegisterDynamicToken(transaction);
    }
    parseRegisterDynamicToken(transactionOnNetwork) {
        return this.parser.parseRegisterDynamicToken(transactionOnNetwork);
    }
    async createTransactionForRegisteringDynamicTokenAndSettingRoles(sender, nonce, options) {
        const transaction = await this.factory.createTransactionForRegisteringDynamicAndSettingRoles(sender.address, options);
        await this.setupAndSignTransaction(transaction, options, nonce, sender);
        return transaction;
    }
    async awaitCompletedRegisterDynamicTokenAndSettingRoles(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseRegisterDynamicTokenAndSettingRoles(transaction);
    }
    parseRegisterDynamicTokenAndSettingRoles(transactionOnNetwork) {
        return this.parser.parseRegisterDynamicTokenAndSettingRoles(transactionOnNetwork);
    }
}
exports.TokenManagementController = TokenManagementController;
//# sourceMappingURL=tokenManagementController.js.map